package openrpc_go_document

import (
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/davecgh/go-spew/spew"
	goopenrpcT "github.com/gregdhill/go-openrpc/types"
)

func DefaultGoRPCServiceProvider(wrapped interface{}) *ServerProviderService {
	return &ServerProviderService{
		ServiceCallbacks:           DefaultSuitableCallbacksGoRPC(wrapped),
		ServiceCallbackToMethod:    DefaultCallbackToMethodGoRPC,
		ServiceOpenRPCInfo:         func() goopenrpcT.Info { return goopenrpcT.Info{} },
		ServiceOpenRPCExternalDocs: nil,
	}
}

func DefaultCallbackToMethodGoRPC(opts *DocumentProviderParseOpts, name string, cb Callback) (*goopenrpcT.Method, error) {
	pcb, err := newParsedCallback(cb)
	if err != nil {
		if strings.Contains(err.Error(), "autogenerated") {
			return nil, errParseCallbackAutoGenerate
		}
		log.Println("parse ethereumCallback", err)
		return nil, err
	}
	method, err := makeGoRPCMethod(opts, name, pcb)
	if err != nil {
		return nil, fmt.Errorf("make method error method=%s cb=%s error=%v", name, spew.Sdump(cb), err)
	}
	return method, nil
}

func makeGoRPCMethod(opts *DocumentProviderParseOpts, name string, pcb *parsedCallback) (*goopenrpcT.Method, error) {

	// Arg, Result
	argTypes := pcb.cb.getArgTypes()
	if len(argTypes) != 2 {
		panic("should be caught in callbacks (registry) method")
	}

	// Error
	retTyptes := pcb.cb.getRetTypes()
	if len(retTyptes) != 1 {
		panic("should be caught in callbacks (registry) method")
	}

	argASTFields := []*NamedField{}
	if pcb.fdecl.Type != nil &&
		pcb.fdecl.Type.Params != nil &&
		pcb.fdecl.Type.Params.List != nil {
		for _, f := range pcb.fdecl.Type.Params.List {
			argASTFields = append(argASTFields, expandASTField(f)...)
		}
	}

	description := func() string {
		return fmt.Sprintf("`%s`", pcb.cb.Func().Type().String())
	}

	contentDescriptor := func(ty reflect.Type, astNamedField *NamedField) (*goopenrpcT.ContentDescriptor, error) {
		sch := typeToSchema(opts, ty)
		if opts != nil && len(opts.SchemaMutationFns) > 0 {
			for _, mutation := range opts.SchemaMutationFns {
				if err := mutation(&sch); err != nil {
					return nil, err
				}
			}
		}
		return &goopenrpcT.ContentDescriptor{
			Content: goopenrpcT.Content{
				Name:        astNamedField.Name,
				Summary:     astNamedField.Field.Comment.Text(),
				Required:    true,
				Description: "mydescription", // fullDescriptionOfType(ty),
				Schema:      sch,
			},
		}, nil
	}

	params := func(skipFn func(isArgs bool, index int, descriptor *goopenrpcT.ContentDescriptor) bool) ([]*goopenrpcT.ContentDescriptor, error) {
		out := []*goopenrpcT.ContentDescriptor{}
		for i, a := range argTypes {
			cd, err := contentDescriptor(a, argASTFields[i])
			if err != nil {
				return nil, err
			}
			if skipFn != nil && skipFn(true, i, cd) {
				continue
			}
			for _, fn := range opts.ContentDescriptorMutationFns {
				fn(true, i, cd)
			}
			out = append(out, cd)
		}
		return out, nil
	}

	runtimeFile, runtimeLine := pcb.runtimeF.FileLine(pcb.runtimeF.Entry())

	collectedParams, err := params(opts.ContentDescriptorSkipFn)
	if err != nil {
		return nil, err
	}

	return &goopenrpcT.Method{
		Name:        name, // pcb.runtimeF.Name(), // FIXME or give me a comment.
		Tags:        nil,
		Summary:     methodSummary(pcb.fdecl),
		Description: description(),
		ExternalDocs: goopenrpcT.ExternalDocs{
			Description: fmt.Sprintf("line=%d", runtimeLine),
			URL:         fmt.Sprintf("file://%s", runtimeFile), // TODO: Provide WORKING external docs links to Github (actually a wrapper/injection to make this configurable).
		},
		Params:         []*goopenrpcT.ContentDescriptor{collectedParams[0]},
		Result:         collectedParams[1],
		Deprecated:     methodDeprecated(pcb.fdecl),
		Servers:        nil,
		Errors:         nil,
		Links:          nil,
		ParamStructure: "",
		Examples:       nil,
	}, nil
}
