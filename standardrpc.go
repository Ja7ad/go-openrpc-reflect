package go_openrpc_reflect

import (
	"fmt"
	"go/token"
	"log"
	"reflect"
	"strings"
	"sync"

	"github.com/davecgh/go-spew/spew"
	goopenrpcT "github.com/gregdhill/go-openrpc/types"
)

/*
StandardRPCDescriptor provides an instance of a reflection service provider
that satisfies the defaults needed to reflect a go standard library rpc package-based
RPC service into an OpenRPC Document.
*/
var StandardRPCDescriptor = &ReceiverServiceDescriptorT{
	ProviderParseOptions:               DefaultParseOptions(),
	ServiceCallbacksFullyQualifiedName: StandardMethodName,
	ServiceCallbacksFromReceiverFn:     DefaultServiceCallbacksStandard,
	ServiceCallbackToMethodFn:          StandardCallbackToMethod,
}

/*
DefaultServiceCallbacksStandard collects suitable methods for a given receiver
in the same way that the go standard library does.
Unfortunately we can't access a standard lib rpc server's registered methods,
so we have to use (replicate) the same logic it uses to aggregate (filtering) them.
*/
var DefaultServiceCallbacksStandard = func(receiver interface{}) map[string]Callback {
	ty := reflect.TypeOf(receiver)
	v := reflect.ValueOf(receiver)

	methods := suitableMethods(ty, true)

	out := make(map[string]Callback)
	for name, vv := range methods {
		cb := Callback{v, vv.method.Func}
		out[name] = cb
	}
	return out
}

/*
StandardMethodName replicates the logic of the go standard library's rpc
package naming convention.
*/
var StandardMethodName = func(receiver interface{}, receiverName, methodName string) string {
	if receiverName != "" {
		return receiverName + "." + methodName
	}
	ty := reflect.TypeOf(receiver)
	if ty.Kind() == reflect.Ptr {
		ty = ty.Elem()
	}
	return ty.Name() + "." + methodName
}

/*
StandardCallbackToMethod parses (reflect, ast) the
given Callback to a corresponding OpenRPC  type Method struct.
*/
var StandardCallbackToMethod = func(opts *DocumentProviderParseOpts, name string, cb Callback) (*goopenrpcT.Method, error) {
	pcb, err := newParsedCallback(cb)
	if err != nil {
		if strings.Contains(err.Error(), "autogenerated") {
			return nil, errParseCallbackAutoGenerate
		}
		log.Println("parse ethereumCallback", err)
		return nil, err
	}
	method, err := makeGoRPCMethod(opts, name, pcb)
	if err != nil {
		return nil, fmt.Errorf("make standard method error method=%s cb=%s error=%v", name, spew.Sdump(cb), err)
	}
	return method, nil
}

func makeGoRPCMethod(opts *DocumentProviderParseOpts, name string, pcb *parsedCallback) (*goopenrpcT.Method, error) {

	argTypes := pcb.cb.getArgTypes()
	// We don' need return types since we know that the only return value can be an error.

	argASTFields := []*NamedField{}
	if pcb.fdecl.Type != nil &&
		pcb.fdecl.Type.Params != nil &&
		pcb.fdecl.Type.Params.List != nil {
		for _, f := range pcb.fdecl.Type.Params.List {
			argASTFields = append(argASTFields, expandASTField(f)...)
		}
	}

	params := func(skipFn func(isArgs bool, index int, ty reflect.Type, descriptor *goopenrpcT.ContentDescriptor) bool) ([]*goopenrpcT.ContentDescriptor, error) {
		out := []*goopenrpcT.ContentDescriptor{}
		for i, a := range argTypes {
			cd, err := opts.contentDescriptor(a, argASTFields[i])
			if err != nil {
				return nil, err
			}
			if skipFn != nil && skipFn(true, i, a, cd) {
				continue
			}
			for _, fn := range opts.ContentDescriptorMutationFns {
				fn(true, i, cd)
			}
			out = append(out, cd)
		}
		return out, nil
	}

	collectedParams, err := params(opts.ContentDescriptorTypeSkipFn)
	if err != nil {
		return nil, err
	}

	return makeMethod(name, pcb, collectedParams[:1], collectedParams[1]), nil
}

// Precompute the reflect type for error. Can't use error directly
// because Typeof takes an empty interface value. This is annoying.
var gorpcTypeOfError = reflect.TypeOf((*error)(nil)).Elem()

type gorpcMethodType struct {
	sync.Mutex // protects counters
	method     reflect.Method
	ArgType    reflect.Type
	ReplyType  reflect.Type
	numCalls   uint
}

// Is this type exported or a builtin?
func isExportedOrBuiltinType(t reflect.Type) bool {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	// PkgPath will be non-empty even for an exported type,
	// so we need to check the type name as well.
	return token.IsExported(t.Name()) || t.PkgPath() == ""
}

// suitableMethods returns suitable Rpc methods of typ, it will report
// error using log if reportErr is true.
func suitableMethods(typ reflect.Type, reportErr bool) map[string]*gorpcMethodType {
	methods := make(map[string]*gorpcMethodType)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mtype := method.Type
		mname := method.Name
		// Method must be exported.
		if method.PkgPath != "" {
			continue
		}
		// Method needs three ins: receiver, *args, *reply.
		if mtype.NumIn() != 3 {
			if reportErr {
				log.Printf("rpc.Register: method %q has %d input parameters; needs exactly three\n", mname, mtype.NumIn())
			}
			continue
		}
		// First arg need not be a pointer.
		argType := mtype.In(1)
		if !isExportedOrBuiltinType(argType) {
			if reportErr {
				log.Printf("rpc.Register: argument type of method %q is not exported: %q\n", mname, argType)
			}
			continue
		}
		// Second arg must be a pointer.
		replyType := mtype.In(2)
		if replyType.Kind() != reflect.Ptr {
			if reportErr {
				log.Printf("rpc.Register: reply type of method %q is not a pointer: %q\n", mname, replyType)
			}
			continue
		}
		// Reply type must be exported.
		if !isExportedOrBuiltinType(replyType) {
			if reportErr {
				log.Printf("rpc.Register: reply type of method %q is not exported: %q\n", mname, replyType)
			}
			continue
		}
		// Method needs one out.
		if mtype.NumOut() != 1 {
			if reportErr {
				log.Printf("rpc.Register: method %q has %d output parameters; needs exactly one\n", mname, mtype.NumOut())
			}
			continue
		}
		// The return type of the method must be error.
		if returnType := mtype.Out(0); returnType != gorpcTypeOfError {
			if reportErr {
				log.Printf("rpc.Register: return type of method %q is %q, must be error\n", mname, returnType)
			}
			continue
		}
		methods[mname] = &gorpcMethodType{method: method, ArgType: argType, ReplyType: replyType}
	}
	return methods
}
