package openrpc_go_document

import (
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/davecgh/go-spew/spew"
	goopenrpcT "github.com/gregdhill/go-openrpc/types"
)

func DefaultServiceCallbackToMethodStandard(opts *DocumentProviderParseOpts, name string, cb Callback) (*goopenrpcT.Method, error) {
	pcb, err := newParsedCallback(cb)
	if err != nil {
		if strings.Contains(err.Error(), "autogenerated") {
			return nil, errParseCallbackAutoGenerate
		}
		log.Println("parse ethereumCallback", err)
		return nil, err
	}
	method, err := makeGoRPCMethod(opts, name, pcb)
	if err != nil {
		return nil, fmt.Errorf("make method error method=%s cb=%s error=%v", name, spew.Sdump(cb), err)
	}
	return method, nil
}

func makeGoRPCMethod(opts *DocumentProviderParseOpts, name string, pcb *parsedCallback) (*goopenrpcT.Method, error) {

	// Arg, Result
	argTypes := pcb.cb.getArgTypes()
	if len(argTypes) != 2 {
		panic("should be caught in callbacks (registry) method")
	}

	// Error
	retTyptes := pcb.cb.getRetTypes()
	if len(retTyptes) != 1 {
		panic("should be caught in callbacks (registry) method")
	}

	argASTFields := []*NamedField{}
	if pcb.fdecl.Type != nil &&
		pcb.fdecl.Type.Params != nil &&
		pcb.fdecl.Type.Params.List != nil {
		for _, f := range pcb.fdecl.Type.Params.List {
			argASTFields = append(argASTFields, expandASTField(f)...)
		}
	}

	description := func() string {
		return fmt.Sprintf("`%s`", pcb.cb.Func().Type().String())
	}

	contentDescriptor := func(ty reflect.Type, astNamedField *NamedField) (*goopenrpcT.ContentDescriptor, error) {
		sch := typeToSchema(opts, ty)
		if opts != nil && len(opts.SchemaMutationFns) > 0 {
			for _, mutation := range opts.SchemaMutationFns {
				if err := mutation(&sch); err != nil {
					return nil, err
				}
			}
		}
		return &goopenrpcT.ContentDescriptor{
			Content: goopenrpcT.Content{
				Name:        astNamedField.Name,
				Summary:     astNamedField.Field.Comment.Text(),
				Required:    true,
				Description: fullTypeDescription(ty),
				Schema:      sch,
			},
		}, nil
	}

	params := func(skipFn func(isArgs bool, index int, descriptor *goopenrpcT.ContentDescriptor) bool) ([]*goopenrpcT.ContentDescriptor, error) {
		out := []*goopenrpcT.ContentDescriptor{}
		for i, a := range argTypes {
			cd, err := contentDescriptor(a, argASTFields[i])
			if err != nil {
				return nil, err
			}
			if skipFn != nil && skipFn(true, i, cd) {
				continue
			}
			for _, fn := range opts.ContentDescriptorMutationFns {
				fn(true, i, cd)
			}
			out = append(out, cd)
		}
		return out, nil
	}

	runtimeFile, runtimeLine := pcb.runtimeF.FileLine(pcb.runtimeF.Entry())

	collectedParams, err := params(opts.ContentDescriptorSkipFn)
	if err != nil {
		return nil, err
	}

	method := newMethod()
	method.Name = name
	method.Summary = methodSummary(pcb.fdecl)
	method.Description = description()
	method.ExternalDocs = goopenrpcT.ExternalDocs{
		Description: fmt.Sprintf("line=%d", runtimeLine),
		URL:         fmt.Sprintf("file://%s", runtimeFile), // TODO: Provide WORKING external docs links to Github (actually a wrapper/injection to make this configurable).
	}
	method.Params = []*goopenrpcT.ContentDescriptor{collectedParams[0]}
	method.Result = collectedParams[1]
	method.Deprecated = methodDeprecated(pcb.fdecl)
	return method, nil

	//return &goopenrpcT.Method{
	//	Name:        name, // pcb.runtimeF.Name(), // FIXME or give me a comment.
	//	Tags:        nil,
	//	Summary:     methodSummary(pcb.fdecl),
	//	Description: description(),
	//	ExternalDocs: goopenrpcT.ExternalDocs{
	//		Description: fmt.Sprintf("line=%d", runtimeLine),
	//		URL:         fmt.Sprintf("file://%s", runtimeFile), // TODO: Provide WORKING external docs links to Github (actually a wrapper/injection to make this configurable).
	//	},
	//	Params:         []*goopenrpcT.ContentDescriptor{collectedParams[0]},
	//	Result:         collectedParams[1],
	//	Deprecated:     methodDeprecated(pcb.fdecl),
	//	Servers:        nil,
	//	Errors:         nil,
	//	Links:          nil,
	//	ParamStructure: "by-position",
	//	Examples:       nil,
	//}, nil
}
