package openrpc_go_document

import (
	"context"
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/davecgh/go-spew/spew"
	go_jsonschema_traverse "github.com/etclabscore/go-jsonschema-traverse"
	goopenrpcT "github.com/gregdhill/go-openrpc/types"
)

var DefaultEthereumServiceProvider = &ReceiverServiceConfigurationProviderService{
	ProviderParseOptions:               DefaultEthereumParseOptions(),
	ServiceCallbacksFullyQualifiedName: DefaultServiceFullyQualifiedNameEthereum,
	ServiceCallbacksFromReceiverFn:     DefaultServiceCallbacksEthereum,
	ServiceCallbackToMethodFn:          DefaultServiceCallbackToMethodEthereum,
}

var DefaultServiceFullyQualifiedNameEthereum = func(receiver interface{}, receiverName, methodName string) string {
	if receiverName != "" {
		return receiverName + "_" + methodName
	}
	ty := reflect.TypeOf(receiver)
	if ty.Kind() == reflect.Ptr {
		ty = ty.Elem()
	}
	return formatEthereumName(ty.Name()) + "_" + methodName
}

// DefaultServiceCallbacksEthereum provides a set of ethereum/go-ethereum/rpc default callbacks.
// This function and associated function duplicate that library's business logic in order
// to pass openrpc-ready names and methods to the openrpc document library.
//
//
var DefaultServiceCallbacksEthereum = func(service interface{}) map[string]Callback {
	v := reflect.ValueOf(service)
	callbacks := suitableCallbacks(v)
	out := make(map[string]Callback)
	for k, v := range callbacks {
		out[k] = *v.Callback()
	}
	return out
}

var DefaultEthereumParseOptions = func() *DocumentProviderParseOpts {
	opts := DefaultParseOptions()
	opts.ContentDescriptorSkipFn = func(isArgs bool, index int, ty reflect.Type, cd *goopenrpcT.ContentDescriptor) bool {
		if isArgs && index == 0 && isContextType(ty) {
			return true
		}
		if !isArgs && isErrorType(ty) {
			return true
		}
		return false
	}
	return opts
}

// DefaultServiceCallbackToMethodEthereum will parse a method to an openrpc method.
// Note that this will collect only the broad strokes:
// - all args, result[0] values => params, result
//
// ContentDescriptors and/or Schema filters must be applied separately.
var DefaultServiceCallbackToMethodEthereum = func(opts *DocumentProviderParseOpts, name string, cb Callback) (*goopenrpcT.Method, error) {
	pcb, err := newParsedCallback(cb)
	if err != nil {
		if strings.Contains(err.Error(), "autogenerated") {
			return nil, errParseCallbackAutoGenerate
		}
		log.Println("parse ethereumCallback", err)
		return nil, err
	}
	method, err := makeEthereumMethod(opts, name, pcb)
	if err != nil {
		return nil, fmt.Errorf("make method error method=%s cb=%s error=%v", name, spew.Sdump(cb), err)
	}
	return method, nil
}

var (
	contextTypeEthereum      = reflect.TypeOf((*context.Context)(nil)).Elem()
	stringType               = reflect.TypeOf("")
)

// ethereumCallback is a method ethereumCallback which was registered in the server
type ethereumCallback struct {
	fn          reflect.Value  // the function
	rcvr        reflect.Value  // receiver object of method, set if fn is method
	argTypes    []reflect.Type // input argument types
	retTypes    []reflect.Type // return types
	hasCtx      bool           // method's first argument is a context (not included in argTypes)
	errPos      int            // err return idx, of -1 when method cannot return error
}

func (e *ethereumCallback) Callback() *Callback {
	return &Callback{
		Receiver: e.rcvr,
		Fn:       e.fn,
	}
}

// suitableCallbacks iterates over the methods of the given type. It determines if a method
// satisfies the criteria for a RPC ethereumCallback or a subscription ethereumCallback and adds it to the
// collection of callbacks. See server documentation for a summary of these criteria.
func suitableCallbacks(receiver reflect.Value) map[string]*ethereumCallback {
	typ := receiver.Type()
	callbacks := make(map[string]*ethereumCallback)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		if method.PkgPath != "" {
			continue // method not exported
		}
		cb := newEthereumCallback(receiver, method.Func)
		if cb == nil {
			continue // function invalid
		}
		name := formatEthereumName(method.Name)
		callbacks[name] = cb
	}
	return callbacks
}

// newCallback turns fn (a function) into a ethereumCallback object. It returns nil if the function
// is unsuitable as an RPC ethereumCallback.
func newEthereumCallback(receiver, fn reflect.Value) *ethereumCallback {
	fntype := fn.Type()
	c := &ethereumCallback{fn: fn, rcvr: receiver, errPos: -1}
	// Determine parameter types. They must all be exported or builtin types.
	c.makeArgTypes()

	// Verify return types. The function must return at most one error
	// and/or one other non-error value.
	outs := make([]reflect.Type, fntype.NumOut())
	for i := 0; i < fntype.NumOut(); i++ {
		outs[i] = fntype.Out(i)
	}
	if len(outs) > 2 {
		return nil
	}
	// If an error is returned, it must be the last returned value.
	switch {
	case len(outs) == 1 && isErrorType(outs[0]):
		c.errPos = 0
	case len(outs) == 2:
		if isErrorType(outs[0]) || !isErrorType(outs[1]) {
			return nil
		}
		c.errPos = 1
	}
	return c
}

// makeArgTypes composes the argTypes list.
func (c *ethereumCallback) makeArgTypes() {
	fntype := c.fn.Type()
	// Skip receiver and context.Context parameter (if present).
	firstArg := 0
	if c.rcvr.IsValid() {
		firstArg++
	}
	if fntype.NumIn() > firstArg && fntype.In(firstArg) == contextTypeEthereum {
		c.hasCtx = true
		firstArg++
	}
	// Add all remaining parameters.
	c.argTypes = make([]reflect.Type, fntype.NumIn()-firstArg)
	for i := firstArg; i < fntype.NumIn(); i++ {
		c.argTypes[i-firstArg] = fntype.In(i)
	}
}

// makeRetTypes composes the argTypes list.
func (c *ethereumCallback) makeRetTypes() {
	fntype := c.fn.Type()
	// Add all remaining parameters.
	c.retTypes = make([]reflect.Type, fntype.NumOut())
	for i := 0; i < fntype.NumOut(); i++ {
		c.retTypes[i] = fntype.Out(i)
	}
}

func makeEthereumMethod(opts *DocumentProviderParseOpts, name string, pcb *parsedCallback) (*goopenrpcT.Method, error) {

	argTypes := pcb.cb.getArgTypes()
	retTyptes := pcb.cb.getRetTypes()

	argASTFields := []*NamedField{}
	if pcb.fdecl.Type != nil &&
		pcb.fdecl.Type.Params != nil &&
		pcb.fdecl.Type.Params.List != nil {
		for _, f := range pcb.fdecl.Type.Params.List {
			argASTFields = append(argASTFields, expandASTField(f)...)
		}
	}

	retASTFields := []*NamedField{}
	if pcb.fdecl.Type != nil &&
		pcb.fdecl.Type.Results != nil &&
		pcb.fdecl.Type.Results.List != nil {
		for _, f := range pcb.fdecl.Type.Results.List {
			retASTFields = append(retASTFields, expandASTField(f)...)
		}
	}

	description := func() string {
		return fmt.Sprintf("```go\n%s\n```", string(pcb.printed))
	}

	contentDescriptor := func(ty reflect.Type, astNamedField *NamedField) (*goopenrpcT.ContentDescriptor, error) {
		sch := typeToSchema(opts, ty)
		if opts != nil && len(opts.SchemaMutationFns) > 0 {
			for _, mutation := range opts.SchemaMutationFns {
				a := go_jsonschema_traverse.NewAnalysisT()
				if err := a.WalkDepthFirst(&sch, mutation); err != nil {
					return nil, fmt.Errorf("schema mutation error: %v", err)
				}
				//if err := mutation(&sch); err != nil {
				//}
			}
		}
		summary := astNamedField.Field.Comment.Text()
		if summary == "" {
			summary = astNamedField.Field.Doc.Text()
		}
		return &goopenrpcT.ContentDescriptor{
			Content: goopenrpcT.Content{
				Name:        astNamedField.Name,
				Summary:     astNamedField.Field.Comment.Text(),
				Required:    true,
				Description: fmt.Sprintf("```go\n%s\n```", fullTypeDescription(ty)),
				Schema:      sch,
			},
		}, nil
	}

	params := func(skipFn func(isArgs bool, index int, ty reflect.Type, descriptor *goopenrpcT.ContentDescriptor) bool) ([]*goopenrpcT.ContentDescriptor, error) {
		out := []*goopenrpcT.ContentDescriptor{}
		for i, a := range argTypes {
			cd, err := contentDescriptor(a, argASTFields[i])
			if err != nil {
				return nil, err
			}
			if skipFn != nil && skipFn(true, i, a, cd) {
				continue
			}
			for _, fn := range opts.ContentDescriptorMutationFns {
				fn(true, i, cd)
			}
			out = append(out, cd)
		}
		return out, nil
	}

	rets := func(skipFn func(isArgs bool, index int, ty reflect.Type, descriptor *goopenrpcT.ContentDescriptor) bool) ([]*goopenrpcT.ContentDescriptor, error) {
		out := []*goopenrpcT.ContentDescriptor{}
		for i, r := range retTyptes {
			cd, err := contentDescriptor(r, retASTFields[i])
			if err != nil {
				return nil, err
			}
			if skipFn != nil && skipFn(false, i, r, cd) {
				continue
			}
			for _, fn := range opts.ContentDescriptorMutationFns {
				fn(false, i, cd)
			}
			out = append(out, cd)
		}
		if len(out) == 0 {
			out = append(out, nullContentDescriptor)
		}
		return out, nil
	}

	runtimeFile, runtimeLine := pcb.runtimeF.FileLine(pcb.runtimeF.Entry())

	collectedParams, err := params(opts.ContentDescriptorSkipFn)
	if err != nil {
		return nil, err
	}
	collectedResults, err := rets(opts.ContentDescriptorSkipFn)
	if err != nil {
		return nil, err
	}
	res := collectedResults[0] // OpenRPC Document specific

	method := newMethod()
	method.Name = name
	method.Summary = methodSummary(pcb.fdecl)
	method.Description = description()
	method.ExternalDocs = goopenrpcT.ExternalDocs{
		Description: fmt.Sprintf("line=%d", runtimeLine),
		URL:         fmt.Sprintf("file://%s", runtimeFile), // TODO: Provide WORKING external docs links to Github (actually a wrapper/injection to make this configurable).
	}
	method.Params = collectedParams
	method.Result = res
	method.Deprecated = methodDeprecated(pcb.fdecl)
	return method, nil

	//return &goopenrpcT.Method{
	//	Name:        name, // pcb.runtimeF.Name(), // FIXME or give me a comment.
	//	Tags:        nil,
	//	Summary:     methodSummary(pcb.fdecl),
	//	Description: description(),
	//	ExternalDocs: goopenrpcT.ExternalDocs{
	//		Description: fmt.Sprintf("line=%d", runtimeLine),
	//		URL:         fmt.Sprintf("file://%s", runtimeFile), // TODO: Provide WORKING external docs links to Github (actually a wrapper/injection to make this configurable).
	//	},
	//	Params:         collectedParams,
	//	Result:         res,
	//	Deprecated:     methodDeprecated(pcb.fdecl),
	//	Servers:        nil,
	//	Errors:         nil,
	//	Links:          nil,
	//	ParamStructure: "by-position",
	//	Examples:       nil,
	//}, nil
	//
}

